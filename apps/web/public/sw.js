// Service Worker for Tournament Management System
// Implements offline-first capabilities with Workbox

// Import Workbox libraries from CDN
importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.0.0/workbox-sw.js');

const { registerRoute } = workbox.routing;
const { CacheFirst, NetworkFirst, StaleWhileRevalidate } = workbox.strategies;
const { CacheableResponsePlugin } = workbox.cacheableResponse;
const { ExpirationPlugin } = workbox.expiration;
const { BackgroundSyncPlugin } = workbox.backgroundSync;
const { precacheAndRoute } = workbox.precaching;

// Service Worker version
const SW_VERSION = '1.0.0';
const CACHE_VERSION = 'v1';
const MAX_CACHE_SIZE = 50 * 1024 * 1024; // 50MB

console.log(`[SW ${SW_VERSION}] Service Worker loading...`);

// Precache static assets generated by Next.js build
precacheAndRoute(self.__WB_MANIFEST || []);

// =============================================================================
// CACHE STRATEGIES
// =============================================================================

// 1. API Routes - Network First with offline fallback
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: `api-cache-${CACHE_VERSION}`,
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// 2. Tournament Data - Stale While Revalidate
registerRoute(
  ({ url }) =>
    url.pathname.includes('/tournaments') ||
    url.pathname.includes('/players') ||
    url.pathname.includes('/matches'),
  new StaleWhileRevalidate({
    cacheName: `tournament-data-${CACHE_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// 3. Static Assets - Cache First
registerRoute(
  ({ request }) =>
    request.destination === 'image' ||
    request.destination === 'font' ||
    request.destination === 'style' ||
    request.destination === 'script',
  new CacheFirst({
    cacheName: `static-assets-${CACHE_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// 4. Google Fonts - Cache First
registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: `google-fonts-${CACHE_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// =============================================================================
// BACKGROUND SYNC FOR OFFLINE ACTIONS
// =============================================================================

// Background sync for score submissions
const scoreSyncPlugin = new BackgroundSyncPlugin('score-submissions', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('[SW] Score submission synced:', entry.request.url);
      } catch (error) {
        console.error('[SW] Score submission failed:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Background sync for tournament actions (check-in, registration)
const tournamentSyncPlugin = new BackgroundSyncPlugin('tournament-actions', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('[SW] Tournament action synced:', entry.request.url);
      } catch (error) {
        console.error('[SW] Tournament action failed:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Register routes that need background sync
registerRoute(
  ({ url }) => url.pathname.includes('/api/matches') && url.pathname.includes('/scores'),
  new NetworkFirst({
    cacheName: `score-updates-${CACHE_VERSION}`,
    plugins: [
      scoreSyncPlugin,
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  }),
  'POST'
);

registerRoute(
  ({ url }) =>
    url.pathname.includes('/api/tournaments') &&
    (url.pathname.includes('/register') || url.pathname.includes('/check-in')),
  new NetworkFirst({
    cacheName: `tournament-actions-${CACHE_VERSION}`,
    plugins: [
      tournamentSyncPlugin,
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  }),
  'POST'
);

// =============================================================================
// OFFLINE FALLBACK
// =============================================================================

// Offline fallback page
const OFFLINE_PAGE = '/offline.html';
const OFFLINE_IMAGE = '/offline-image.svg';

// Cache offline fallback resources during install
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');

  event.waitUntil(
    caches.open(`offline-${CACHE_VERSION}`).then((cache) => {
      return cache.addAll([
        OFFLINE_PAGE,
        OFFLINE_IMAGE,
      ]);
    })
  );

  // Activate immediately
  self.skipWaiting();
});

// Serve offline fallback when network fails
self.addEventListener('fetch', (event) => {
  // Only handle navigation requests (page loads)
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match(OFFLINE_PAGE);
      })
    );
  }
});

// =============================================================================
// CACHE MANAGEMENT
// =============================================================================

// Clean up old caches during activation
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');

  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            // Delete caches from previous versions
            return !cacheName.includes(CACHE_VERSION);
          })
          .map((cacheName) => {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );
    })
  );

  // Take control immediately
  return self.clients.claim();
});

// Monitor cache size
async function checkCacheSize() {
  const cacheNames = await caches.keys();
  let totalSize = 0;

  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();

    for (const request of keys) {
      const response = await cache.match(request);
      if (response) {
        const blob = await response.blob();
        totalSize += blob.size;
      }
    }
  }

  console.log(`[SW] Total cache size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);

  // If cache is too large, clear oldest entries
  if (totalSize > MAX_CACHE_SIZE) {
    console.warn('[SW] Cache size exceeded limit, clearing oldest entries...');
    // Workbox ExpirationPlugin handles this automatically
  }

  return totalSize;
}

// Check cache size periodically
setInterval(() => {
  checkCacheSize();
}, 60 * 60 * 1000); // Every hour

// =============================================================================
// MESSAGE HANDLING
// =============================================================================

// Handle messages from clients
self.addEventListener('message', (event) => {
  console.log('[SW] Received message:', event.data);

  if (event.data && event.data.type) {
    switch (event.data.type) {
      case 'SKIP_WAITING':
        self.skipWaiting();
        break;

      case 'CACHE_STATS':
        checkCacheSize().then((size) => {
          event.ports[0].postMessage({
            type: 'CACHE_STATS_RESPONSE',
            size,
          });
        });
        break;

      case 'CLEAR_CACHE':
        caches.keys().then((cacheNames) => {
          return Promise.all(
            cacheNames.map((cacheName) => caches.delete(cacheName))
          );
        }).then(() => {
          event.ports[0].postMessage({
            type: 'CACHE_CLEARED',
          });
        });
        break;

      case 'SYNC_STATUS':
        // Return sync queue status
        event.ports[0].postMessage({
          type: 'SYNC_STATUS_RESPONSE',
          queues: {
            scores: 0, // Would need to query actual queue
            actions: 0,
          },
        });
        break;
    }
  }
});

// =============================================================================
// PUSH NOTIFICATIONS
// Sprint 10 Week 4 - Enhanced push notification handling
// =============================================================================

self.addEventListener('push', (event) => {
  console.log('[SW] Push notification received');

  let notificationData = {
    title: 'Tournament Update',
    body: 'New update available',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'default',
    data: {
      url: '/',
      type: 'announcement',
    },
  };

  if (event.data) {
    try {
      const parsedData = event.data.json();
      notificationData = { ...notificationData, ...parsedData };
    } catch (error) {
      console.error('[SW] Error parsing push data:', error);
    }
  }

  const options = {
    body: notificationData.body,
    icon: notificationData.icon || '/icons/icon-192x192.png',
    badge: notificationData.badge || '/icons/badge-72x72.png',
    tag: notificationData.tag || 'default',
    vibrate: [200, 100, 200],
    requireInteraction: notificationData.data?.type === 'match', // Require interaction for match notifications
    data: notificationData.data,
    actions: notificationData.actions || [],
  };

  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
  );
});

self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification clicked');

  event.notification.close();

  // Handle action clicks
  if (event.action) {
    console.log('[SW] Notification action clicked:', event.action);
    // Handle specific actions based on event.action
  }

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // Open new window
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Track notification dismissals
self.addEventListener('notificationclose', (event) => {
  console.log('[SW] Notification closed', event.notification.tag);

  // Optional: Track notification dismissals
  event.waitUntil(
    fetch('/api/analytics/events', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        event: 'notification_dismissed',
        properties: {
          tag: event.notification.tag,
          type: event.notification.data?.type,
          timestamp: new Date().toISOString(),
        },
      }),
    }).catch((error) => {
      console.error('[SW] Failed to track notification dismissal:', error);
    })
  );
});

console.log(`[SW ${SW_VERSION}] Service Worker loaded successfully`);
