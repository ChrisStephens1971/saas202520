#!/bin/bash
#
# Pre-commit hook with auto-fix capabilities
#
# Auto-fixes:
# - Trailing whitespace removal
# - Line ending normalization (CRLF â†’ LF)
# - Missing final newlines
# - Code formatting (black for Python, prettier for JS/JSON/MD)
#
# Validates:
# - No unreplaced placeholders ({{...}})
# - No secrets in .env.local files
# - Markdown syntax (if markdownlint available)
#
# Installation:
#   git config core.hooksPath .githooks
#
# Configuration: .git/hooks-config
#   AUTO_FIX_WHITESPACE=true/false
#   AUTO_FIX_LINE_ENDINGS=true/false
#   AUTO_FIX_FINAL_NEWLINE=true/false
#   AUTO_FORMAT_CODE=true/false
#
# Author: Template System
# Created: 2025-11-02
# Updated: 2025-11-07 (added auto-fix)

set -e

# Load configuration
CONFIG_FILE=".git/hooks-config"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Default values if not configured
: ${AUTO_FIX_WHITESPACE:=true}
: ${AUTO_FIX_LINE_ENDINGS:=true}
: ${AUTO_FIX_FINAL_NEWLINE:=true}
: ${AUTO_FORMAT_CODE:=true}

echo "ðŸ”§ Running pre-commit auto-fix..."

# Get list of staged files (excluding .githooks/)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -v "^\.githooks/" || true)

if [ -z "$STAGED_FILES" ]; then
    echo "  No files to process"
else
    FIX_COUNT=0

    # PHASE 1: AUTO-FIX (modifies files and re-stages)

    for file in $STAGED_FILES; do
        # Skip binary files and non-existent files
        if [ ! -f "$file" ] || file "$file" | grep -q "binary"; then
            continue
        fi

        FILE_MODIFIED=false

        # Fix 1: Remove trailing whitespace
        if [ "$AUTO_FIX_WHITESPACE" = "true" ]; then
            if grep -q '[[:space:]]$' "$file" 2>/dev/null; then
                sed -i 's/[[:space:]]*$//' "$file"
                FILE_MODIFIED=true
                echo "  âœ“ Removed trailing whitespace from $file"
                ((FIX_COUNT++))
            fi
        fi

        # Fix 2: Normalize line endings (CRLF â†’ LF)
        if [ "$AUTO_FIX_LINE_ENDINGS" = "true" ]; then
            if file "$file" | grep -q "CRLF"; then
                # Try dos2unix first, fall back to sed
                if command -v dos2unix &> /dev/null; then
                    dos2unix "$file" 2>/dev/null
                else
                    sed -i 's/\r$//' "$file"
                fi
                FILE_MODIFIED=true
                echo "  âœ“ Normalized line endings in $file"
                ((FIX_COUNT++))
            fi
        fi

        # Fix 3: Ensure final newline
        if [ "$AUTO_FIX_FINAL_NEWLINE" = "true" ]; then
            if [ -n "$(tail -c 1 "$file" 2>/dev/null)" ]; then
                echo "" >> "$file"
                FILE_MODIFIED=true
                echo "  âœ“ Added final newline to $file"
                ((FIX_COUNT++))
            fi
        fi

        # Fix 4: Auto-format code
        if [ "$AUTO_FORMAT_CODE" = "true" ]; then
            case "$file" in
                *.py)
                    if command -v black &> /dev/null; then
                        if black --check "$file" &>/dev/null; then
                            : # Already formatted
                        else
                            black "$file" &>/dev/null
                            FILE_MODIFIED=true
                            echo "  âœ“ Formatted $file with black"
                            ((FIX_COUNT++))
                        fi
                    fi
                    ;;
                *.js|*.json|*.md)
                    if command -v prettier &> /dev/null; then
                        if prettier --check "$file" &>/dev/null; then
                            : # Already formatted
                        else
                            prettier --write "$file" &>/dev/null
                            FILE_MODIFIED=true
                            echo "  âœ“ Formatted $file with prettier"
                            ((FIX_COUNT++))
                        fi
                    fi
                    ;;
            esac
        fi

        # Re-stage file if it was modified
        if [ "$FILE_MODIFIED" = "true" ]; then
            git add "$file"
        fi
    done

    if [ $FIX_COUNT -gt 0 ]; then
        echo "  Auto-fixed $FIX_COUNT issue(s)"
    else
        echo "  No auto-fixes needed"
    fi
fi

# PHASE 2: VALIDATION (blocks commit if issues found)

echo "ðŸ” Running validation..."

# Check for unreplaced placeholders
echo "  Checking for unreplaced placeholders..."
STAGED_FILES=$(git diff --cached --name-only | grep -v "^\.githooks/" || true)
if [ -n "$STAGED_FILES" ]; then
    if echo "$STAGED_FILES" | xargs grep -l "{{" 2>/dev/null; then
        echo "âŒ ERROR: Found unreplaced placeholders in staged files:"
        echo "$STAGED_FILES" | xargs grep -n "{{"
        echo ""
        echo "Please replace all {{PLACEHOLDER}} values before committing."
        exit 1
    fi
fi

# Check for secrets in .env.local
if git diff --cached --name-only | grep -q "\.env\.local"; then
    echo "âŒ ERROR: Attempting to commit .env.local file"
    echo ""
    echo ".env.local should never be committed (contains secrets)."
    echo "This file is in .gitignore. Please unstage it:"
    echo "  git reset HEAD .env.local"
    exit 1
fi

# Check markdown syntax (if markdownlint is available)
if command -v markdownlint &> /dev/null; then
    echo "  Checking markdown syntax..."
    MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep "\.md$" || true)
    if [ -n "$MD_FILES" ]; then
        if ! echo "$MD_FILES" | xargs markdownlint --config .markdownlint.json 2>/dev/null; then
            echo "âš ï¸  WARNING: Markdown linting issues found (not blocking commit)"
        fi
    fi
fi

# Validate daily practices (strict mode)
if [ -f "scripts/validate-daily-practices.sh" ]; then
    echo "  Checking daily practices..."
    if bash scripts/validate-daily-practices.sh 2>&1; then
        echo "  âœ… Daily practices validated"
    else
        echo ""
        echo "To bypass daily practices check (not recommended):"
        echo "  git commit --no-verify"
        exit 1
    fi
fi

echo "âœ… Pre-commit validation passed"
exit 0
