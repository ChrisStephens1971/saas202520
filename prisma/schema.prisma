// Tournament Platform - Prisma Schema
// Multi-tenant architecture with Row-Level Security (RLS)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USERS & AUTHENTICATION
// ============================================================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  password      String? // For credentials provider (hashed)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  accounts           Account[]
  sessions           Session[]
  organizationMembers OrganizationMember[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================================================
// ORGANIZATIONS (Multi-Tenant)
// ============================================================================

model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  members     OrganizationMember[]
  tournaments Tournament[]

  @@map("organizations")
}

model OrganizationMember {
  id     String @id @default(cuid())
  orgId  String @map("org_id")
  userId String @map("user_id")
  role   String // owner, td, scorekeeper, streamer

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([orgId])
  @@index([userId])
  @@map("organization_members")
}

// ============================================================================
// TOURNAMENTS
// ============================================================================

model Tournament {
  id                  String   @id @default(cuid())
  orgId               String   @map("org_id") // Tenant ID
  name                String
  description         String? // Optional tournament description
  status              String // draft, registration, active, paused, completed, cancelled
  format              String // single_elimination, double_elimination, round_robin, modified_single, chip_format
  sportConfigId       String   @map("sport_config_id")
  sportConfigVersion  String   @map("sport_config_version") // Frozen at creation
  createdBy           String   @map("created_by")
  createdAt           DateTime @default(now()) @map("created_at")
  startedAt           DateTime? @map("started_at")
  completedAt         DateTime? @map("completed_at")

  // Relations
  organization   Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  players        Player[]
  matches        Match[]
  tables         Table[]
  events         TournamentEvent[]

  @@index([orgId])
  @@index([status])
  @@index([createdAt])
  @@map("tournaments")
}

// ============================================================================
// EVENT-SOURCED AUDIT LOG (Append-Only)
// ============================================================================

model TournamentEvent {
  id           String   @id @default(cuid())
  tournamentId String   @map("tournament_id")
  kind         String // event type (tournament.created, player.registered, etc.)
  actor        String // User ID who performed the action
  device       String // Device ID for CRDT sync
  payload      Json // Event-specific data
  timestamp    DateTime @default(now())

  // Relations
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@index([tournamentId])
  @@index([timestamp])
  @@index([kind])
  @@map("tournament_events")
}

// ============================================================================
// PLAYERS
// ============================================================================

model Player {
  id           String   @id @default(cuid())
  tournamentId String   @map("tournament_id")
  name         String
  email        String?
  phone        String?
  rating       Json? // { system: "apa" | "fargo" | "bca", value: number | string }
  status       String // registered, checked_in, active, eliminated, no_show, withdrawn
  seed         Int?
  checkedInAt  DateTime? @map("checked_in_at")
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  tournament       Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  matchesAsPlayerA Match[]    @relation("PlayerA")
  matchesAsPlayerB Match[]    @relation("PlayerB")

  @@index([tournamentId])
  @@index([status])
  @@map("players")
}

// ============================================================================
// MATCHES
// ============================================================================

model Match {
  id           String   @id @default(cuid())
  tournamentId String   @map("tournament_id")
  round        Int
  bracket      String? // winners, losers (null for non-bracket formats)
  position     Int // Position in bracket/round
  playerAId    String?  @map("player_a_id")
  playerBId    String?  @map("player_b_id")
  state        String // pending, ready, assigned, active, completed, cancelled
  winnerId     String?  @map("winner_id")
  score        Json // { playerA: number, playerB: number, raceTo?: number, games?: GameScore[] }
  tableId      String?  @map("table_id")
  startedAt    DateTime? @map("started_at")
  completedAt  DateTime? @map("completed_at")
  rev          Int      @default(0) // Optimistic locking

  // Relations
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  playerA    Player?    @relation("PlayerA", fields: [playerAId], references: [id])
  playerB    Player?    @relation("PlayerB", fields: [playerBId], references: [id])
  table      Table?     @relation(fields: [tableId], references: [id])

  @@index([tournamentId])
  @@index([state])
  @@index([tableId])
  @@index([round])
  @@map("matches")
}

// ============================================================================
// TABLES
// ============================================================================

model Table {
  id             String   @id @default(cuid())
  tournamentId   String   @map("tournament_id")
  label          String // e.g., "Table 1", "Back Corner"
  status         String // available, in_use, blocked
  blockedUntil   DateTime? @map("blocked_until")
  currentMatchId String?  @map("current_match_id")

  // Relations
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  matches    Match[]

  @@index([tournamentId])
  @@index([status])
  @@map("tables")
}

// ============================================================================
// SPORT CONFIGURATIONS (Versioned, Frozen per Tournament)
// ============================================================================

model SportConfig {
  id               String   @id @default(cuid())
  name             String // e.g., "Pool 8-Ball", "Pool 9-Ball"
  sport            String // pool, darts, cornhole (future)
  rules            Json // Sport-specific rules
  scoringSchema    Json     @map("scoring_schema")
  bracketTemplates Json     @map("bracket_templates")
  version          String // Semantic version
  createdAt        DateTime @default(now()) @map("created_at")

  @@unique([name, version])
  @@index([sport])
  @@map("sport_configs")
}

// ============================================================================
// SCORING SYSTEM (Sprint 3 - SCORE-001 to SCORE-007)
// ============================================================================

model ScoreUpdate {
  id           String   @id @default(cuid())
  matchId      String   @map("match_id")
  tournamentId String   @map("tournament_id")
  actor        String // User ID who entered the score
  device       String // Device ID
  action       String // increment_a, increment_b, undo
  previousScore Json   @map("previous_score") // Score snapshot before this action
  newScore     Json     @map("new_score") // Score snapshot after this action
  timestamp    DateTime @default(now())
  undone       Boolean  @default(false) // True if this action was undone

  @@index([matchId])
  @@index([tournamentId])
  @@index([timestamp])
  @@map("score_updates")
}

// ============================================================================
// PAYMENT SYSTEM (Sprint 3 - PAY-001 to PAY-008)
// ============================================================================

model StripeAccount {
  id                    String   @id @default(cuid())
  orgId                 String   @unique @map("org_id") // One Stripe account per organization
  stripeAccountId       String   @unique @map("stripe_account_id") // Stripe Connect account ID
  onboardingComplete    Boolean  @default(false) @map("onboarding_complete")
  chargesEnabled        Boolean  @default(false) @map("charges_enabled")
  payoutsEnabled        Boolean  @default(false) @map("payouts_enabled")
  detailsSubmitted      Boolean  @default(false) @map("details_submitted")
  country               String?
  currency              String?  @default("usd")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  // Relations
  payments Payment[]

  @@index([orgId])
  @@map("stripe_accounts")
}

model Payment {
  id                  String   @id @default(cuid())
  tournamentId        String   @map("tournament_id")
  playerId            String?  @map("player_id") // Optional - may be null for manual payments
  stripeAccountId     String   @map("stripe_account_id")
  stripePaymentIntent String   @unique @map("stripe_payment_intent") // Stripe PaymentIntent ID
  amount              Int // Amount in cents
  currency            String   @default("usd")
  status              String // pending, succeeded, failed, refunded, partially_refunded
  purpose             String // entry_fee, side_pot, addon
  description         String?
  refundedAmount      Int      @default(0) @map("refunded_amount") // Amount refunded in cents
  receiptUrl          String?  @map("receipt_url")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  stripeAccount StripeAccount @relation(fields: [stripeAccountId], references: [id])
  refunds       Refund[]

  @@index([tournamentId])
  @@index([playerId])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

model Refund {
  id              String   @id @default(cuid())
  paymentId       String   @map("payment_id")
  stripeRefundId  String   @unique @map("stripe_refund_id") // Stripe Refund ID
  amount          Int // Amount refunded in cents
  reason          String // duplicate, fraudulent, requested_by_customer
  status          String // pending, succeeded, failed, cancelled
  processedBy     String   @map("processed_by") // User ID who processed the refund
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([createdAt])
  @@map("refunds")
}

model Payout {
  id              String   @id @default(cuid())
  tournamentId    String   @map("tournament_id")
  playerId        String   @map("player_id")
  placement       Int // 1st, 2nd, 3rd, etc.
  amount          Int // Payout amount in cents
  source          String // prize_pool, side_pot
  status          String // pending, paid, voided
  paidAt          DateTime? @map("paid_at")
  paidBy          String?  @map("paid_by") // User ID who marked as paid
  notes           String?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([tournamentId])
  @@index([playerId])
  @@index([status])
  @@map("payouts")
}
